#+TITLE: zerok's Emacs configuration
#+OPTIONS: toc:2
* General Emacs settings
** Snippets

Not much to add here. Snippets are simply a great thing to work with:

#+BEGIN_SRC emacs-lisp
(require 'yasnippet)
(yas-global-mode 1)
#+END_SRC

** Unicode fonts
#+BEGIN_SRC emacs-lisp
(set-fontset-font t 'unicode "Symbola" nil 'prepend)
(require 'unicode-fonts)
(unicode-fonts-setup)
#+END_SRC
** Theme
#+begin_src emacs-lisp
;(load-theme 'smyx t)
(require 'moe-theme)
(load-theme 'moe-dark t)
(require 'powerline)
(require 'powerline-evil)
(powerline-moe-theme)
#+end_src
** Enable evil mode

While most of Emacs is great, the editing experience I've come to love from
using VIM for more than a decade is something I don't want to miss. And if I can
combine that with the awesome development environment that Emacs+LISP is: All
the better!

#+begin_src emacs-lisp
(evil-mode 1)
#+end_src

In order still to be able to use C-u, I've remapped page-up and page-down to C-k
and C-j as described on
http://juanjoalvarez.net/es/detail/2014/sep/19/vim-emacsevil-chaotic-migration-guide/ .

#+begin_src emacs-lisp
(define-key evil-normal-state-map (kbd "C-k") (lambda ()
                    (interactive)
                    (evil-scroll-up nil)))
(define-key evil-normal-state-map (kbd "C-j") (lambda ()
                        (interactive)
                        (evil-scroll-down nil)))
#+end_src

** Simple confirmation

By default Emacs asks for "yes" or "no" during confirmation dialogs. "y" and "n"
should really suffice...

#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

** OSX Integration
#+BEGIN_SRC emacs-lisp
(when (memq window-system '(mac ns))
  (exec-path-from-shell-initialize))
#+END_SRC
** Indentation & line width
#+begin_src emacs-lisp
(setq-default fill-column 80)
(setq-default indent-tabs-mode nil) ;; don't use tabs
(setq-default tab-width 4)
;(setq indent-line-function 'insert-tab)
(indent-guide-global-mode)
#+end_src

And disable auto-fill-mode by default as it tends to get in the way. I just
enable it whenever I need it.

#+begin_src emacs-lisp
(auto-fill-mode -1)
#+end_src

*** The Meta key

I need the Options/Alt key for special characters on the US intl. keyboard and
therefore can't use it as the Meta key. Instead I'm using the CMD key since all
I'd use it for otherwise is for interactions with the clipboard.

#+begin_src emacs-lisp
(setq mac-option-modifier 'none)
#+end_src

*** Shared clipboard

http://stackoverflow.com/questions/64360/how-to-copy-text-from-emacs-to-another-application-on-linux

#+begin_src emacs-lisp
(setq x-select-enable-clipboard t)
#+end_src

** Renaming the current buffer & file

#+begin_src emacs-lisp
;; source: http://steve.yegge.googlepages.com/my-dot-emacs-file
(defun rename-file-and-buffer (new-name)
  "Renames both current buffer and file it's visiting to NEW-NAME."
  (interactive "sNew name: ")
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not filename)
        (message "Buffer '%s' is not visiting a file!" name)
      (if (get-buffer new-name)
          (message "A buffer named '%s' already exists!" new-name)
        (progn
          (rename-file name new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil))))))
#+end_src

** IDO and Helm

I really like the way esp. Helm allows for easy navigation within the options
buffers. So I basically enabled Helm and IDO in multiple places to make this
whole process easier.

#+begin_src emacs-lisp
(require 'helm-config)
(ido-mode 1)
(ido-everywhere 1)
(setq ido-use-faces nil)
#+end_src

** Line handling
#+BEGIN_SRC emacs-lisp
(add-hook 'markdown-mode-hook 'auto-fill-mode)
(add-hook 'rst-mode-hook 'auto-fill-mode)
(add-hook 'org-mode-hook 'auto-fill-mode)
(add-hook 'prog-mode-hook 'toggle-truncate-lines)
(global-linum-mode 1) ;; show the current line number in the gutter
(global-hl-line-mode 1) ;; highlight the currentl ine
#+END_SRC

** Executable scripts
Whenever I work on a file that has a '#!' header, I'm pretty sure I want to make
it executable. Since I tend to forget that, Emacs should do that for me on:

#+BEGIN_SRC emacs-lisp
(defun zerok-make-script-executable ()
  "Checks if the current file is a script and if so makes it executable"
  (interactive)
  (save-excursion
    (goto-char 0)
    (when (looking-at "^#!/")
      (when (not (file-executable-p buffer-file-name))
        (set-file-modes buffer-file-name (logior 73 (file-modes buffer-file-name)))
        )
      )
    )
  )
(add-hook 'after-save-hook 'zerok-make-script-executable)
#+END_SRC
** Remove blank lines
http://www.emacswiki.org/emacs/DeletingWhitespace

#+begin_src emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src
** Enable auto-completion globally
#+BEGIN_SRC emacs-lisp
(setq company-dabbrev-downcase nil)
(global-company-mode 1)
#+END_SRC
** Show matching parens
#+BEGIN_SRC emacs-lisp
;; http://emacswiki.org/emacs/ShowParenMode
(show-paren-mode 1)
#+END_SRC
** Re-enable restricted functions
#+BEGIN_SRC emacs-lisp
(put 'narrow-to-region 'disabled nil)
(put 'upcase-region 'disabled nil)
#+END_SRC
** Code checking
#+BEGIN_SRC
(add-hook 'after-init-hook #'global-flycheck-mode) ;; static code checking
#+END_SRC
** Custom mode mapping
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.zshrc\\.(local|private)\\'". sh-mode))
#+END_SRC
** NeoTree

In NeoTree I prefer to have toggling automatically jump to the folder of the
buffer I'm currently at:

#+BEGIN_SRC emacs-lisp
(setq neo-smart-open t)
#+END_SRC

* Locale
** First day of the week
Where I live we consider Monday to be the first day of the week, so I want my
calendars to think so to:

#+BEGIN_SRC emacs-lisp
(setq calendar-week-start-day 1)
#+END_SRC
* Keybindings
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-i") 'helm-imenu)
(global-set-key (kbd "M-1") 'delete-other-windows)
(global-set-key (kbd "M-2") 'split-window-vertically)
(global-set-key (kbd "M-3") 'split-window-horizontally)
(global-set-key (kbd "C-o") 'other-window)
(global-set-key (kbd "M-x") 'helm-M-x)
(global-set-key (kbd "C-x C-b") 'helm-buffers-list)
(global-set-key (kbd "C-+") 'text-scale-increase)
(global-set-key (kbd "C--") 'text-scale-decrease)
(global-set-key (kbd "C-c l l") 'toggle-truncate-lines)
(global-set-key (kbd "M-z") 'undo)
(global-set-key (kbd "C-c a") 'org-agenda)
(global-set-key (kbd "C-M-c") 'org-capture)
(global-set-key (kbd "C-c C-x C-j") 'org-clock-goto)
(global-set-key (kbd "C-c C-r") 'replace-string)
(global-set-key (kbd "M-t") 'helm-cmd-t)
(global-set-key (kbd "<f8>") 'neotree-toggle)
(global-set-key (kbd "C-<f6>") 'magit-status)
(global-set-key (kbd "<f9>") 'avy-goto-char)
(global-set-key (kbd "M-e") 'er/expand-region)
(global-set-key (kbd "C-c k") 'company-complete)
(global-set-key (kbd "C-c C-<SPC>") 'point-to-register)
(global-set-key (kbd "C-c C-j") 'jump-to-register)
(global-set-key (kbd "C-j") 'emmet-expand-line)
(global-set-key (kbd "C-s") 'swiper)
#+END_SRC

For some things it makes sense not to loose the prefix. Text-zooming is the
first example you learn about when looking at the hydra website and it's a good
one ðŸ˜‰

#+BEGIN_SRC emacs-lisp
(defhydra hydra-zoom (global-map "<f2>")
  "zoom"
  ("k" text-scale-increase "in")
  ("j" text-scale-decrease "out"))
#+END_SRC
** Emojis
#+BEGIN_SRC emacs-lisp
(setq zerok/emoji-map (make-sparse-keymap))
;; Smiling face with open mouth
(define-key zerok/emoji-map
  (kbd "1")
  (lambda () (interactive) (insert-char #x1F603 1 t)))
;; Winking
(define-key zerok/emoji-map
  (kbd "2")
  (lambda () (interactive) (insert-char #x1F609 1 t)))
;; Smiling face with smiling eyes
(define-key zerok/emoji-map
  (kbd "3")
  (lambda () (interactive) (insert-char #x1F60A 1 t)))
(define-key zerok/emoji-map
  (kbd "4")
  (lambda () (interactive) (insert "Â¯\\_(ãƒ„)_/Â¯")))
(global-set-key (kbd "C-M-o") zerok/emoji-map)
#+END_SRC

** Misc

Some other helpers that try to emulate VIM behavior outside of evil-mode:

#+BEGIN_SRC emacs-lisp
;; http://stackoverflow.com/questions/23692879/emacs24-backtab-is-undefined-how-to-define-this-shortcut-key
(global-set-key (kbd "<backtab>") 'un-indent-by-removing-4-spaces)
(defun un-indent-by-removing-4-spaces ()
  "remove 4 spaces from beginning of of line"
  (interactive)
  (save-excursion
    (save-match-data
      (beginning-of-line)
      ;; get rid of tabs at beginning of line
      (when (looking-at "^\\s-+")
        (untabify (match-beginning 0) (match-end 0)))
      (when (looking-at (concat "^" (make-string tab-width 32)))
        (replace-match "")))))

;; Based on http://emacsredux.com/blog/2013/06/15/open-line-above/
(global-set-key (kbd "C-S-<return>") 'newline-above)
(defun newline-above ()
  "Creates a new empty line above the current one"
  (interactive)
  (move-beginning-of-line nil)
  (newline-and-indent)
  (forward-line -1)
  (indent-according-to-mode)
  )
;; A simple way to always create a new line wherever you are within the current line
(global-set-key (kbd "S-<return>") 'smart-newline)
(defun smart-newline ()
  "Creates a newline below the current one no matter where in
that line the user currenty is."
  (interactive)
  (move-end-of-line nil)
  (newline-and-indent))

(global-set-key (kbd "M-l") 'duplicate-line)
(defun duplicate-line ()
  "Duplicates the current lines below and moves the point there."
  (interactive)
  (let ((col (current-column)))
    (save-excursion
      (kill-whole-line 1)
      (yank)
      (yank)
      )
    (forward-line)
    (move-to-column col)
    )
  )
#+END_SRC
** Commenting

Override for M-; to actually comment out a line instead of adding a comment
after it:

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-;") 'toggle-line-comment)
(defun toggle-line-comment ()
  "Toggles commenting of the current line or all lines in the current region"
  (interactive)
  (if (region-active-p)
      (save-excursion
        (let (
              (end-of-region (region-end))
              (start-of-region 0)
              )
          (goto-char (region-beginning))
          (setq start-of-region (line-beginning-position))
          (goto-char end-of-region)
          (comment-or-uncomment-region start-of-region (line-end-position))
          ))
    (comment-or-uncomment-region (line-beginning-position) (line-end-position))))
#+END_SRC

* Basic typing

** Automatic closing braces

Since version 24 Emacs comes with the electric-pair mode which supports creating
things like closing braces, quotes etc.

#+begin_src emacs-lisp
(electric-pair-mode 1)
#+end_src

* Major modes
** Markdown

I was really stupid and started using Markdown years ago with the wrong file
extension, so now I have to asign "*.mdown" extensions to Markdown in whatever
editor I use ...

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.mdown\\'" . markdown-mode))
#+end_src
*** Encoding and Decoding

For some reason Emacs doesn't come out of the box with helpers for encoding and
decoding HTML entities, which is annoying when you work with Markdown.

So I needed my own ones:

#+begin_src emacs-lisp
  (defun zs-html-encode ()
    "Escape relevant characters as HTML entities in this region"
    (interactive)
    (save-excursion
      (narrow-to-region (region-beginning) (region-end))
      (let (element
            (escapings '(
                         ("&" "&amp;")
                         ("<" "&lt;")
                         (">" "&gt;")
                         )))
        (dolist (element escapings)
          (goto-char (point-min))
          (replace-string (car element) (car (cdr element)))
          )
        )
      (widen)
    )
  )
#+end_src

*** Disable auto-compilation

#+begin_src emacs-lisp
(setq scss-compile-at-save nil)
#+end_src

*** Reference handling

By default markdown-mode will add references after the current
paragraph/section. Personally, I prefer them to be put at the end of the file to
feel more similar to things like footnotes:

#+BEGIN_SRC emacs=lisp
(setq markdown-reference-location 'end)
#+END_SRC

*** Preview
#+BEGIN_SRC emacs-lisp
(defun zerok/preview-markdown ()
  "This opens Marked App to generate a preview of the given file"
  (interactive)
  (shell-command (format "open -a Marked\\ 2 %s" (buffer-file-name))))
#+END_SRC
** JavaScript

I really prefer js2-mode over js-mode ðŸ˜‰

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist (cons (rx ".js" eos) 'js2-mode))
#+END_SRC

For working with React it helps if imenu is working properly with it's internal
object structure:

#+BEGIN_SRC emacs-lisp
(add-hook 'js2-mode-hook 'js2-imenu-extras-mode)
#+END_SRC

Indenting esp. for consts is a bit weird. Some projects like the next line (in a
combined declaration) to be at the 6th column while others prefer it to continue
with the default indentation (e.g. 4). To make rotating here easier, js2-mode
offers a nice setting:

#+BEGIN_SRC emacs-lisp
(setq js2-bounce-indent-p t)
#+END_SRC

*** JSONLinting
Not much to compile for JSON files so I thought I'd simply hook jsonlinting into
the compile command:

#+BEGIN_SRC emacs-lisp
(defun zerok/compile-json-setup ()
  "For JSON files I'd like the compile command to execute jsonlint by default"
  (when (and (not (string-empty-p buffer-file-name)) (string-suffix-p ".json" buffer-file-name))
    (set (make-local-variable 'compilation-read-command)
         nil)
    (set (make-local-variable 'compile-command)
         (concat "jsonlint -q " (shell-quote-argument buffer-file-name)))))

(add-hook 'js-mode-hook 'zerok/compile-json-setup)
#+END_SRC
*** JSCS with Flycheck

Right now I don't use JSCS anymore in favor of ESLint, but this would add a
simple handler to Flycheck that doesn't die whenever you are in a project that
doesn't use JSCS ...

#+BEGIN_SRC emacs-lisp
(require 'flycheck)
;;; Code
;; https://github.com/ananthakumaran/dotfiles/blob/master/.emacs.d/init-js.el
(flycheck-define-checker javascript-jscs
  "A JavaScript code style checker. See URL `https://github.com/mdevils/node-jscs'."
  :command ("/Users/zerok/.local/bin/smart-jscs.py" "--reporter" "checkstyle" source)
  :error-parser flycheck-parse-checkstyle
  ;; :next-checkers (javascript-jshint)
  :modes (js-mode js2-mode))

;; (add-to-list 'flycheck-checkers 'javascript-jscs)
#+END_SRC
*** JSX support

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.jsx\\'" . jsx-mode))
(autoload 'jsx-mode "jsx-mode" "JSX mode" t)
#+END_SRC

*** Webmode

For JSX from https://truongtx.me/2014/03/10/emacs-setup-jsx-mode-and-jsx-syntax-checking/

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.jsx$" . web-mode))
(defadvice web-mode-highlight-part (around tweak-jsx activate)
  (if (equal web-mode-content-type "jsx")
      (let ((web-mode-enable-part-face nil))
        ad-do-it)
    ad-do-it))
#+END_SRC

** Python
*** Completion with JEDI
#+BEGIN_SRC emacs-lisp
(add-hook 'python-mode-hook 'jedi:setup)
(setq jedi:complete-on-dot t)
#+END_SRC
** Sass/SCSS
** HTML

By default SGML documents have a indentation of 2 characters. Seems like you
can't use global settings here but have to override that SGML-internal variable:

#+begin_src emacs-lisp
(setq sgml-basic-offset 4)
#+end_src
** Restructured Text (rst)

It is rather tiring to underline headlines manually. This little helper allows
me to just enter one character of the pattern below a line and complete it to
the lenght of the line above it with C-c C-c.

#+begin_src emacs-lisp
(require 'rst)
(defun zs-rst-complete-heading ()
  "zs-rst-complete-headline completes the headline indicator for the length of the headline"
  (interactive)
  (let (
        (length-to-end 0)
        (start-point 0)
        (headline-char (char-before))
        )
    (save-excursion
      (previous-line)
      (setq start-point (point))
      (move-end-of-line nil)
      (setq length-to-end (- (point) start-point))
      )
    (insert (make-string length-to-end headline-char))
    )
  )

(define-key rst-mode-map "\C-c\C-c" 'zs-rst-complete-heading)
#+end_src
** Rust
#+BEGIN_SRC emacs-lisp
(eval-after-load 'flycheck
  '(add-hook 'flycheck-mode-hook #'flycheck-rust-setup))
#+END_SRC
** Elixir
#+BEGIN_SRC emacs-lisp
(setq elixir-compiler-command  "/usr/local/bin/elixirc")
(setq alchemist-mix-command "/usr/local/bin/mix")
(setq alchemist-iex-program-name "/usr/local/bin/iex")
(setq alchemist-execute-command "/usr/local/bin/elixir")
(setq alchemist-compile-command "/usr/local/bin/elixirc")
(defun zerok/elixir-mode-tabwidth-setup ()
  ""
  (setq tab-width 2))
(add-hook 'elixir-mode-hook 'zerok/elixir-mode-tabwidth-setup)
#+END_SRC
** Golang
First, let's set up the basic system including compilation and company support:

#+BEGIN_SRC emacs-lisp
  (setq gofmt-command "goimports")
  (add-hook 'before-save-hook 'gofmt-before-save)
  (defun zerok/go-mode-compilation-setup ()
    "Configures the compilation command for go mode"
    (set (make-local-variable 'compilation-read-command) nil)
    (set (make-local-variable 'compile-command) "go vet && go build"))
  (defun zerok/go-mode-enable-company ()
    "Enable company-go in go-mode"
    (set (make-local-variable 'company-backends) '(company-go))
    (company-mode))
  (add-hook 'go-mode-hook 'zerok/go-mode-compilation-setup)
  (add-hook 'go-mode-hook 'zerok/go-mode-enable-company)
#+END_SRC
*** Support for GB projects
#+BEGIN_SRC emacs-lisp
(defun zerok/setup-gb-gopath ()
  (interactive)
  (make-local-variable 'process-environment)
  (let (
        (srcPath (_zerok/get-gb-src-folder buffer-file-name))
        )
    (when srcPath
      (let* (
            (projectPath (string-remove-suffix "/" (file-name-directory srcPath)))
            (vendorPath (string-remove-suffix "/" (concat projectPath "/vendor")))
            (gopath (concat vendorPath ":" projectPath))
            )
        (progn
          (message "Updating GOPATH to %s" gopath)
          (setenv "GOPATH" gopath)
          )
        ))))
(add-hook 'go-mode-hook 'zerok/setup-gb-gopath)

(defun _zerok/get-gb-src-folder (path)
  (let (
        (parent (directory-file-name (file-name-directory path)))
        (basename (file-name-nondirectory path))
        )
    (if (equal "src" basename)
        (string-remove-suffix "/" path)
      (if (equal "/" parent)
          nil
        (_zerok/get-gb-src-folder parent)
        )
      )
    )
  )
#+END_SRC
** YAML

   RAML is also only just a special YAML file:

   #+BEGIN_SRC emacs-lisp
   (add-to-list 'auto-mode-alist '("\\.raml\\'" . yaml-mode))
   #+END_SRC

** Clojure

Highlight-parentheses-mode is immensely useful when you're deep down in nested
parens:

#+BEGIN_SRC emacs-lisp
  (require 'highlight-parentheses)
  (defun zerok/clojure-hook-highlight-parens-mode ()
    "Enable highlight-parenthesis-mode when entering clojure mode"
    (highlight-parentheses-mode t))
  (add-hook 'clojure-mode-hook 'zerok/clojure-hook-highlight-parens-mode)
#+END_SRC
* OrgMode
** Daily Standup Report
I tend to forget what I was working on the previous day so I want to easily be
able to generate a report of all the items I've booked time on the day before:

#+BEGIN_SRC emacs-lisp
(defun zs-is-weekday-p (date)
  "Checks if a given date object represents a weekday."
  (let ((daterepr (format-time-string "%w" date)))
    (member daterepr (list "1" "2" "3" "4" "5"))
    ))

(defun zs-get-previous-workday ()
  "Returns the date object for the previous workday"
  (let ((start (time-subtract (current-time) (seconds-to-time 86400))))
    (while (not (zs-is-weekday-p start))
      (setq start (time-subtract start (seconds-to-time 86400)))
      )
    (format-time-string "%Y-%m-%d" start)
    )
  )

(defun zs-prepare-standup-report ()
  "This updates my table on yesterdays bookings and exports it to HTML."
  (interactive)
  (save-excursion
    (let (
          (date (zs-get-previous-workday))
          )
      (find-file "~/org/yesterdays-bookings.org")
      (goto-char (point-min))
      (replace-regexp ":block [[:digit:]]\\{4\\}-[[:digit:]]\\{2\\}-[[:digit:]]\\{2\\}"
                      (format ":block %s" date)
                      nil 0 (point-max) nil)
      (org-ctrl-c-ctrl-c)
      (save-buffer)
      (org-html-export-to-html)
      (kill-buffer)
      )
    )
  )

#+END_SRC
** Navigating sections
Navigating between sections in a document was never easier :-)

#+begin_src emacs-lisp
(add-hook 'org-mode-hook (lambda()
                           (require 'helm-org)
                           (global-set-key (kbd "C-c o h") 'helm-org-in-buffer-headings)
                           ))
#+end_src

** Other stuff

When using export make sure to always use UTF-8:

#+BEGIN_SRC emacs-lisp
(setq org-export-coding-system 'utf-8)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-custom-commands
        '(("h" "Tasks in the home context"
           ((agenda "" (
                        (org-agenda-start-day "-1d")
                        (org-agenda-start-on-weekday nil)
                        (org-agenda-entry-types '(:deadline :scheduled))
                        (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo '("DONE" "WAITING" "CANCELLED")))
                        ))
            (tags-todo "@home-TODO=\"WAITING\"-TODO=\"DONE\"-TODO=\"CANCELLED\"" (
                                                                                  (org-agenda-todo-ignore-scheduled 'future)
                                                                                  (org-agenda-tags-todo-honor-ignore-options t)
                                                                                  ))
            ) nil ("~/org/home.html"))
          ("i" "Inbox"
           ((tags-todo "CATEGORY=\"inbox\"")) nil ("~/org/inbox.html"))
          ("w" "Tasks in the work context"
           ((agenda "" (
                        (org-agenda-entry-types '(:deadline :scheduled))
                        (org-agenda-start-day "-1d")
                        (org-agenda-start-on-weekday nil)
                        (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo '("DONE" "WAITING" "CANCELLED")))
                        ))
            (tags-todo "@work-TODO=\"WAITING\"-TODO=\"DONE\"-TODO=\"CANCELLED\"")) nil ("~/org/work.html"))
          ("r" "Tasks for review"
           ((tags-todo "TODO=\"WAITING\"")))
          )
        )
  (setq org-todo-keywords
        '((sequence "TODO(t)" "STARTED(s)" "WAITING(w)" "|" "DONE(d)" "CANCELLED(c)"))
        )
  (setq org-tag-alist '(("@work" . ?w) ("@home" . ?h)))
  (setq org-log-done 'time)
  (setq org-agenda-files '("~/org" "~/org/travel"))
  (setq org-enforce-todo-dependencies t)
  (setq org-clock-into-drawer 1)
  (setq org-log-into-drawer t)
  (setq org-refile-targets '((nil . (:level . 1)) (nil . (:level . 2)) ))
#+END_SRC

** Capture templates

I primarily use OrgMode to capture things like meeting notes and personal
journal entries. As such the two primary capture templates are "n" for notes,
which ends up as timestamped files in ~/notes, and "j" for journal entries saved
into ~/journal.

"t" (todo) I mostly keep for now in case I want to ever use OrgMode as GTD tool
again. Probably nothing for the immediate feature but that option doesn't hurt.

#+BEGIN_SRC emacs-lisp
(defun zs-get-current-journal-file ()
  "This returns the journal file that should be used for today."
  (format-time-string "~/journal/%Y/%Y-%m-%d.org")
  )

(defun zs-get-previous-journal-file ()
  "Returns the path to the journal file of the previous day."
  (format-time-string "~/journal/%Y/%Y-%m-%d.org" (time-subtract (current-time) (seconds-to-time 86400))))

(defun journal-today ()
  "Opens the current journal file"
  (interactive)
  (find-file (zs-get-current-journal-file)))

(defun journal-yesterday ()
  "Opens the journal file of the previous day"
  (interactive)
  (find-file (zs-get-previous-journal-file)))

(defun zerok/capture-note-file ()
  "Generate a new note file name based on user input and the current time"
  (let ((name (read-string "Name: "))
        (prefix (format-time-string "~/notes/%Y/%Y%m%d_%H%M")))
    (format "%s-%s.org" prefix name)))

(setq org-capture-templates
      '(("t" "Todo" entry (file+headline "~/org/gtd.org" "Inbox")
         "* TODO %?\n  :PROPERTIES:\n  :CREATED: %T\n  :END:\n")
        ("n" "Notes" plain (file zerok/capture-note-file)
         "%?\n")
        ("j" "Journal" entry (file (zs-get-current-journal-file))
         "* %?\n\n  CREATED: %T"
         :empty-lines 1)
        ))

#+END_SRC
** Notes navigation

In order to have easy access to the most recent notes I've created a small helm
helper that lists all this year's notes in reverse order with the most recent on
the very top:

#+BEGIN_SRC emacs-lisp
  (defun zerok/recent-notes--open-note ()
    "Just the callback that is executed when a note has been selected."
    (interactive)
    (helm-exit-and-execute-action (lambda (candidate)
                                    (find-file (car candidate)))))

  (defun zerok/recent-notes--display-name (path)
    "Prepares the display version of a given note's path"
    (replace-regexp-in-string "\\([[:digit:]]+_[[:digit:]]+\\)-\\(.*\\)" "[\\1] \\2" (file-name-base path)))

  (defun zerok/recent-notes--find-notes ()
    "Returns a list of (notename . fullpath) pairs for the latest 10 notes."
    (let* ((current-year (format-time-string "%Y"))
          (base-path (format "~/notes/%s" current-year)))
      (mapcar (lambda (file) (cons (zerok/recent-notes--display-name file) (cons file ())))
              (reverse (directory-files base-path t "\\.org$")))))

  (defun zerok/recent-notes ()
    ""
    (interactive)
    (let ((keys (make-sparse-keymap)))
      (define-key keys (kbd "<RET>") 'zerok/recent-notes--open-note)
      (helm :sources (helm-build-sync-source "Recent notes"
                       :candidates (zerok/recent-notes--find-notes)
                       :keymap keys
                       :fuzzy-match t)
            :buffer "*helm notes*")))
#+END_SRC
** Auto-Export Dropbox notes
I put notes that I might share with other people or that I want to have
available on the go in Dropbox. As the official Dropbox client doesn't really
support .org files these should be exported automatically to HTML whenever I
change them.

#+BEGIN_SRC emacs-lisp
(defun zerok/org-autoexport-dropbox ()
  "Automatically generates a HTML export of the current orgmode file if it is stored in Dropbox"
  (when (and buffer-file-name (string-match-p "/Dropbox/.*.org" buffer-file-name))
    (org-html-export-to-html)))

(add-hook 'after-save-hook 'zerok/org-autoexport-dropbox)
#+END_SRC
** HTML Export

I wasn't really happy with the default CSS used for the generated HTML files so
I was looking for a way to include my own definitions. I still want that style
to be include inline in the generated HTML file so that I can simply drop the
document onto Dropbox and not worry about reachable links.

Sadly, =org-html-head= can only be set to a string and not to a function
generating a string, so simply reading a CSS file from somewhere and adding its
content to every generated HTML file got a bit more complicated:

#+BEGIN_SRC emacs-lisp
(setq org-html-head-include-default-style nil)
(defun zerok/generate-org-style (backend)
  ""
  (let ((stylefile "~/.emacs.d/org-style.css"))
    (when (and (file-exists-p stylefile) (file-readable-p stylefile))
      (with-temp-buffer
        (insert-file-contents stylefile)
        (setq org-html-head (concat "<style>" (buffer-string) "</style>"))))))
(add-hook 'org-export-before-processing-hook 'zerok/generate-org-style)
#+END_SRC
* Project management

Enable projectile everywhere:

#+BEGIN_SRC emacs-lisp
(projectile-global-mode)
#+END_SRC
* EvilMode
** Disable evil-mode in specific situations

As much as I like evil-mode, I don't want it active where it gets in the way
with some other major or special modes like neotree et al. until I've found
some good ways to integrate it better there:

#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'neotree-mode 'emacs)
(evil-set-initial-state 'dired-mode 'emacs)
(evil-set-initial-state 'shell-mode 'emacs)
(evil-set-initial-state 'magit-popup-mode 'emacs)
#+END_SRC

** Leader hotkeys

Probably the single best thing about keybindings in VIM is that you by default
have a namespace for them thanks to the leader-key. It was only a matter of time
before I added evil-leader to my Emacs configuration and remapped some of my
most commonly used shortcuts:

#+BEGIN_SRC emacs-lisp
(global-evil-leader-mode)
(evil-leader/set-leader "\\")
(evil-leader/set-key
    "t" 'helm-cmd-t
    "b" 'helm-buffers-list
    "k" 'kill-buffer
    "gs" 'magit-status
    "c" 'compile
    "n" 'next-error
    "\\" 'avy-goto-char
    )
#+END_SRC
** evil-commentary

I've use Tim Pope's awesome [[https://github.com/linktohack/evil-commentary][vim-commentary]] extension for so many years that it
has become really hard to get it out of my system. But why should I when there
is [[https://github.com/linktohack/evil-commentary][evil-commentary]] out there :-D

#+BEGIN_SRC emacs-lisp
(evil-commentary-mode)
#+END_SRC
* Blogging

For my blog I've create a handful of helper scripts to make working with drafts
easier. To make drafting even easier, though, I needed a way to integrate them
with my Emacs setup. This is where =blog/craft-draft= comes in. It will use my
external scripts to generate a new draft and also open the main file:


#+BEGIN_SRC emacs-lisp
(defun blog/create-draft (draftname)
  "This creates a new post draft and opens the index.mdown file in it."
  (interactive "sSlug: ")
  (when (eq 0 (shell-command (concat "blogcli create-draft -slug=" draftname)))
    (find-file (concat "~/blog/drafts/" draftname "/index.md"))))
#+END_SRC

Something else that I do quite often is insert images into my posts. Snippets
don't work that well here for me for some reason, so here comes a custom
function:

#+BEGIN_SRC emacs-lisp
  (defun blog/insert-fig (imgsrc caption)
    "This inserts a new figure into on the current cursor position"
    (interactive "FImage Source: \nsCaption: ")
    (let* ((current-directory (file-name-directory buffer-file-name))
           (image-directory (file-name-directory imgsrc)))
      (if (string= current-directory image-directory)
          (insert (concat "<figure>\n    <img src=\"" (file-name-nondirectory imgsrc) "\" alt=\"\" />\n    <figcaption><p>" caption "</p></figcaption>\n</figure>"))
        (message "The image file has to be in the same directory as the post."))))
#+END_SRC
